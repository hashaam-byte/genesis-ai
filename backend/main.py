"""
GENESIS AI - Complete Backend v4.0
FINAL VERSION with Ultimate AI Integration
Save as: backend/main.py
"""

from fastapi import FastAPI, HTTPException, BackgroundTasks
from fastapi.middleware.cors import CORSMiddleware
from pydantic import BaseModel
from typing import Optional, List, Dict, Any
import asyncio
from datetime import datetime
import os
import json
from pathlib import Path

# Import Ultimate AI Engine
try:
    from ultimate_ai import UltimateAI
    ai_engine = UltimateAI()
    AI_AVAILABLE = True
except Exception as e:
    print(f"‚ö†Ô∏è  AI Engine error: {e}")
    AI_AVAILABLE = False
    ai_engine = None

app = FastAPI(
    title="GENESIS AI",
    version="4.0.0 - Ultimate Edition",
    description="The most powerful autonomous AI builder"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Allow any origin for API usage
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ============ DATA MODELS ============

class ProjectRequest(BaseModel):
    prompt: str
    project_type: Optional[str] = "auto"
    output_path: Optional[str] = None
    run_tests: Optional[bool] = False
    create_files: Optional[bool] = True

class TaskStep(BaseModel):
    step_number: int
    description: str
    status: str
    output: Optional[str] = None
    details: Optional[str] = None
    estimated_time: Optional[str] = None
    ai_used: Optional[str] = None

class ProjectResponse(BaseModel):
    project_id: str
    status: str
    plan: List[TaskStep]
    files_created: List[str]
    errors: List[str]
    logs: List[str]
    code_preview: Optional[Dict[str, str]] = None
    tech_stack: Optional[List[str]] = None
    ai_providers_used: Optional[List[str]] = None
    cost_estimate: Optional[str] = None
    output_directory: Optional[str] = None
    download_url: Optional[str] = None

class SimplePrompt(BaseModel):
    prompt: str
    task_type: Optional[str] = "general"  # general, code, review, architecture

class SimpleResponse(BaseModel):
    response: str
    provider: str
    cost: float
    timestamp: str

# ============ STORAGE ============

projects = {}
PROJECTS_DIR = Path("./generated_projects")
PROJECTS_DIR.mkdir(exist_ok=True)

# ============ FILE SYSTEM MANAGER ============

class FileSystemManager:
    """Manages actual file creation on disk"""
    
    @staticmethod
    def create_project_structure(project_id: str, project_type: str) -> Path:
        """Create project folder structure"""
        project_path = PROJECTS_DIR / project_id
        project_path.mkdir(exist_ok=True)
        
        if project_type == "web_app":
            (project_path / "src").mkdir(exist_ok=True)
            (project_path / "src" / "components").mkdir(exist_ok=True)
            (project_path / "server").mkdir(exist_ok=True)
            (project_path / "database").mkdir(exist_ok=True)
            (project_path / "public").mkdir(exist_ok=True)
        
        elif project_type == "game":
            (project_path / "Assets").mkdir(exist_ok=True)
            (project_path / "Assets" / "Scripts").mkdir(exist_ok=True)
            (project_path / "Assets" / "Models").mkdir(exist_ok=True)
            (project_path / "Assets" / "Scenes").mkdir(exist_ok=True)
        
        elif project_type == "mobile_app":
            (project_path / "src").mkdir(exist_ok=True)
            (project_path / "src" / "screens").mkdir(exist_ok=True)
            (project_path / "src" / "components").mkdir(exist_ok=True)
        
        return project_path
    
    @staticmethod
    def write_file(project_path: Path, filepath: str, content: str):
        """Write code to file"""
        full_path = project_path / filepath
        full_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(content)
    
    @staticmethod
    def create_readme(project_path: Path, project_info: Dict):
        """Create README.md"""
        readme = f"""# {project_info.get('name', 'Generated Project')}

## Generated by GENESIS AI

**Project Type:** {project_info.get('type', 'N/A')}
**Tech Stack:** {', '.join(project_info.get('tech_stack', []))}
**Created:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Description
{project_info.get('prompt', 'AI-generated project')}

## Getting Started

### Installation
```bash
npm install
```

### Development
```bash
npm run dev
```

### Build
```bash
npm run build
```

## Project Structure
- `src/` - Source code
- `server/` - Backend code
- `database/` - Database schemas

---
**Built with ‚ù§Ô∏è by GENESIS AI**
"""
        with open(project_path / "README.md", 'w') as f:
            f.write(readme)
    
    @staticmethod
    def create_package_json(project_path: Path, project_info: Dict):
        """Create package.json"""
        package = {
            "name": project_info.get('name', 'genesis-project'),
            "version": "1.0.0",
            "description": project_info.get('prompt', '')[:100],
            "scripts": {
                "dev": "vite",
                "build": "vite build",
                "start": "node server/index.js"
            },
            "dependencies": {
                "react": "^18.2.0",
                "react-dom": "^18.2.0"
            },
            "devDependencies": {
                "vite": "^5.0.0",
                "@vitejs/plugin-react": "^4.2.0"
            }
        }
        
        with open(project_path / "package.json", 'w') as f:
            json.dump(package, f, indent=2)

# ============ CODE EXECUTOR ============

class CodeExecutor:
    """Runs and tests generated code"""
    
    @staticmethod
    async def run_tests(project_path: Path, project_type: str) -> Dict:
        """Run automated tests"""
        results = {
            "passed": True,
            "tests_run": 0,
            "errors": []
        }
        
        # Check if files exist
        if project_type == "web_app":
            required_files = ["src/App.tsx", "server/index.js"]
            for file in required_files:
                if not (project_path / file).exists():
                    results["passed"] = False
                    results["errors"].append(f"Missing file: {file}")
                else:
                    results["tests_run"] += 1
        
        # TODO: Add actual code execution and testing
        
        return results

# ============ MEMORY SYSTEM ============

class MemorySystem:
    """Learns from past projects and mistakes"""
    
    def __init__(self):
        self.memory_file = Path("./memory/project_memory.json")
        self.memory_file.parent.mkdir(exist_ok=True)
        self.memory = self._load_memory()
    
    def _load_memory(self) -> Dict:
        """Load memory from disk"""
        if self.memory_file.exists():
            with open(self.memory_file, 'r') as f:
                return json.load(f)
        return {
            "successful_patterns": [],
            "common_errors": [],
            "tech_stack_preferences": {},
            "project_count": 0
        }
    
    def _save_memory(self):
        """Save memory to disk"""
        with open(self.memory_file, 'w') as f:
            json.dump(self.memory, f, indent=2)
    
    def record_success(self, project_type: str, tech_stack: List[str], prompt: str):
        """Record successful project"""
        self.memory["project_count"] += 1
        self.memory["successful_patterns"].append({
            "type": project_type,
            "stack": tech_stack,
            "prompt_keywords": prompt.split()[:10],
            "timestamp": datetime.now().isoformat()
        })
        self._save_memory()
    
    def record_error(self, error: str, context: Dict):
        """Record error for learning"""
        self.memory["common_errors"].append({
            "error": error,
            "context": context,
            "timestamp": datetime.now().isoformat()
        })
        self._save_memory()
    
    def get_recommendations(self, project_type: str) -> List[str]:
        """Get recommendations based on past successes"""
        patterns = [p for p in self.memory["successful_patterns"] 
                   if p["type"] == project_type]
        
        if patterns:
            # Return most common tech stacks
            stacks = [p["stack"] for p in patterns[-5:]]
            return stacks[0] if stacks else []
        return []

memory_system = MemorySystem()

# ============ ORCHESTRATOR ============

class Orchestrator:
    """The Brain - Complete Version"""
    
    @staticmethod
    async def process_request(request: ProjectRequest) -> ProjectResponse:
        """Main pipeline - COMPLETE"""
        project_id = f"proj_{datetime.now().strftime('%Y%m%d_%H%M%S')}"
        logs = []
        ai_providers_used = set()
        
        def log(message: str):
            timestamp = datetime.now().strftime('%H:%M:%S')
            log_msg = f"[{timestamp}] {message}"
            logs.append(log_msg)
            print(log_msg)
        
        if not AI_AVAILABLE:
            raise Exception("AI Engine not available")
        
        log(f"üöÄ Starting project: {project_id}")
        log(f"üìù Prompt: {request.prompt[:100]}...")
        
        # Detect project type
        if request.project_type == "auto":
            project_type = await Orchestrator.detect_project_type(request.prompt)
        else:
            project_type = request.project_type
        log(f"üéØ Type: {project_type}")
        
        # Check memory for recommendations
        recommendations = memory_system.get_recommendations(project_type)
        if recommendations:
            log(f"üí° Using learned patterns from {memory_system.memory['project_count']} past projects")
        
        # Create project structure
        project_path = None
        if request.create_files:
            log("üìÅ Creating project structure...")
            project_path = FileSystemManager.create_project_structure(project_id, project_type)
            log(f"   Created: {project_path}")
        
        # AI-powered tech stack
        log("üîß Analyzing tech stack...")
        result = ai_engine.analyze_tech_stack(request.prompt, project_type)
        tech_stack = result if isinstance(result, list) else []
        ai_providers_used.add(ai_engine.primary_ai if hasattr(ai_engine, 'primary_ai') else 'unknown')
        log(f"   Stack: {', '.join(tech_stack)}")
        
        # Generate plan
        log("üìã Creating execution plan...")
        plan_result = ai_engine.generate_plan(request.prompt, project_type)
        plan = [
            TaskStep(
                step_number=step["step_number"],
                description=step["description"],
                status="pending",
                estimated_time=step.get("estimated_time", "~3 min")
            )
            for step in plan_result.get("plan", [])
        ]
        log(f"   Plan: {len(plan)} steps")
        
        # Execute plan
        result = await Orchestrator.execute_plan(
            project_id, plan, request.prompt, logs, tech_stack, 
            ai_providers_used, project_path, request.create_files
        )
        
        # Run tests if requested
        if request.run_tests and project_path:
            log("üß™ Running tests...")
            test_results = await CodeExecutor.run_tests(project_path, project_type)
            if test_results["passed"]:
                log(f"   ‚úÖ All {test_results['tests_run']} tests passed")
            else:
                log(f"   ‚ùå Tests failed: {test_results['errors']}")
                result.errors.extend(test_results["errors"])
        
        # Record success in memory
        if result.status == "complete":
            memory_system.record_success(project_type, tech_stack, request.prompt)
            log("üíæ Learning from this project...")
        
        # Calculate cost
        if ai_engine and hasattr(ai_engine, 'stats'):
            stats = ai_engine.get_stats()
            result.cost_estimate = f"${stats.get('total_cost', 0):.4f}"
        else:
            result.cost_estimate = "$0.00"
        
        result.ai_providers_used = list(ai_providers_used)
        result.output_directory = str(project_path) if project_path else None
        
        log("‚úÖ Project complete!")
        
        return result
    
    @staticmethod
    async def detect_project_type(prompt: str) -> str:
        """Detect project type"""
        prompt_lower = prompt.lower()
        
        if any(w in prompt_lower for w in ["game", "unity", "3d", "blender"]):
            return "game"
        elif any(w in prompt_lower for w in ["mobile", "app", "ios", "android"]):
            return "mobile_app"
        elif any(w in prompt_lower for w in ["api", "rest", "backend"]):
            return "api"
        else:
            return "web_app"
    
    @staticmethod
    async def execute_plan(
        project_id: str, plan: List[TaskStep], prompt: str,
        logs: List[str], tech_stack: List[str], ai_providers_used: set,
        project_path: Optional[Path], create_files: bool
    ) -> ProjectResponse:
        """Execute plan with file creation"""
        
        files_created = []
        errors = []
        code_preview = {}
        
        def log(message: str):
            timestamp = datetime.now().strftime('%H:%M:%S')
            logs.append(f"[{timestamp}] {message}")
        
        context = {
            "prompt": prompt,
            "tech_stack": ", ".join(tech_stack),
            "project_type": "web_app"
        }
        
        for step in plan:
            step.status = "running"
            log(f"‚ñ∂Ô∏è  {step.description}")
            
            try:
                await asyncio.sleep(0.1)
                
                # Generate code based on step
                if "frontend" in step.description.lower():
                    log("   üé® Generating frontend...")
                    context["target_file"] = "src/App.tsx"
                    result = ai_engine.generate_code(step.description, context)
                    code = result.get("text", result)
                    code_preview["src/App.tsx"] = code
                    
                    if create_files and project_path:
                        FileSystemManager.write_file(project_path, "src/App.tsx", code)
                        FileSystemManager.write_file(project_path, "src/index.tsx", 
                            "import React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\n\nReactDOM.createRoot(document.getElementById('root')!).render(<App />);")
                    
                    files_created.extend(["src/App.tsx", "src/index.tsx"])
                    step.ai_used = result.get("provider", "unknown")
                    log(f"   ‚úì Generated {len(code.split(chr(10)))} lines")
                
                elif "backend" in step.description.lower():
                    log("   ‚öôÔ∏è  Generating backend...")
                    context["target_file"] = "server/index.js"
                    result = ai_engine.generate_code(step.description, context)
                    code = result.get("text", result)
                    code_preview["server/index.js"] = code
                    
                    if create_files and project_path:
                        FileSystemManager.write_file(project_path, "server/index.js", code)
                    
                    files_created.append("server/index.js")
                    log("   ‚úì Backend created")
                
                elif "database" in step.description.lower():
                    log("   üóÑÔ∏è  Creating schema...")
                    context["target_file"] = "database/schema.sql"
                    result = ai_engine.generate_code(step.description, context)
                    code = result.get("text", result)
                    code_preview["database/schema.sql"] = code
                    
                    if create_files and project_path:
                        FileSystemManager.write_file(project_path, "database/schema.sql", code)
                    
                    files_created.append("database/schema.sql")
                
                else:
                    log(f"   ‚úì {step.description}")
                
                step.status = "complete"
                step.output = "‚úì Completed"
                
            except Exception as e:
                step.status = "failed"
                error_msg = f"Step {step.step_number} failed: {str(e)}"
                errors.append(error_msg)
                log(f"   ‚úó {error_msg}")
                memory_system.record_error(error_msg, {"step": step.description})
                break
        
        # Create README and package.json
        if create_files and project_path:
            FileSystemManager.create_readme(project_path, {
                "name": project_id,
                "type": context["project_type"],
                "tech_stack": tech_stack,
                "prompt": prompt
            })
            FileSystemManager.create_package_json(project_path, {
                "name": project_id,
                "prompt": prompt
            })
            files_created.extend(["README.md", "package.json"])
        
        final_status = "complete" if not errors else "failed"
        log(f"{'‚úÖ' if final_status == 'complete' else '‚ùå'} {final_status.upper()}")
        log(f"üì¶ {len(files_created)} files")
        
        response = ProjectResponse(
            project_id=project_id,
            status=final_status,
            plan=plan,
            files_created=files_created,
            errors=errors,
            logs=logs,
            code_preview=code_preview,
            tech_stack=tech_stack
        )
        
        projects[project_id] = response
        return response

# ============ API ENDPOINTS ============

@app.get("/")
async def root():
    """API root - shows status"""
    return {
        "name": "GENESIS AI",
        "version": "4.0.0 - Ultimate Edition",
        "status": "running",
        "features": [
            "Multi-AI support (Groq, Gemini, Claude, ChatGPT)",
            "File system integration",
            "Code execution",
            "Memory & learning",
            "Project templates",
            "API service for external apps"
        ],
        "ai_enabled": AI_AVAILABLE,
        "projects_generated": memory_system.memory["project_count"],
        "endpoints": {
            "generate_project": "/api/generate",
            "simple_prompt": "/api/prompt",
            "project_status": "/api/project/{id}",
            "health": "/api/health",
            "stats": "/api/stats"
        }
    }

@app.post("/api/generate", response_model=ProjectResponse)
async def generate_project(request: ProjectRequest):
    """Generate complete project"""
    try:
        result = await Orchestrator.process_request(request)
        return result
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/prompt", response_model=SimpleResponse)
async def simple_prompt(request: SimplePrompt):
    """
    Simple prompt endpoint for external apps
    Use GENESIS AI for ANY task, not just coding
    """
    if not AI_AVAILABLE:
        raise HTTPException(status_code=503, detail="AI not available")
    
    try:
        result = ai_engine.generate(
            request.prompt,
            system_prompt="",
            task_type=request.task_type
        )
        
        return SimpleResponse(
            response=result.get("text", str(result)),
            provider=result.get("provider", "unknown"),
            cost=result.get("cost", 0.0),
            timestamp=datetime.now().isoformat()
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/project/{project_id}", response_model=ProjectResponse)
async def get_project(project_id: str):
    """Get project by ID"""
    if project_id not in projects:
        raise HTTPException(status_code=404, detail="Project not found")
    return projects[project_id]

@app.get("/api/health")
async def health():
    """Health check"""
    return {
        "status": "healthy",
        "ai_available": AI_AVAILABLE,
        "projects": len(projects),
        "memory_projects": memory_system.memory["project_count"],
        "timestamp": datetime.now().isoformat()
    }

@app.get("/api/stats")
async def get_stats():
    """Get usage statistics"""
    stats = {
        "total_projects": memory_system.memory["project_count"],
        "active_projects": len(projects),
        "memory_size_kb": memory_system.memory_file.stat().st_size / 1024 if memory_system.memory_file.exists() else 0
    }
    
    if AI_AVAILABLE and hasattr(ai_engine, 'get_stats'):
        ai_stats = ai_engine.get_stats()
        stats.update(ai_stats)
    
    return stats

if __name__ == "__main__":
    import uvicorn
    print("=" * 70)
    print("üöÄ GENESIS AI v4.0 - ULTIMATE EDITION")
    print("=" * 70)
    print(f"üß† AI Available: {AI_AVAILABLE}")
    print(f"üíæ Projects Generated: {memory_system.memory['project_count']}")
    print(f"üìç Backend: http://localhost:8000")
    print(f"üìç API Docs: http://localhost:8000/docs")
    print(f"üìç Simple API: POST /api/prompt (for external apps)")
    print("=" * 70)
    uvicorn.run(app, host="0.0.0.0", port=8000, log_level="info")